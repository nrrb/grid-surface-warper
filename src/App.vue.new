<template>
  <h1>Grid Surface Warper</h1>
  <div class="controls">
    <label>
      Grid Spacing:
      <input type="range" v-model="spacing" min="10" max="100" value="30">
    </label>
    <template v-if="surfaceType === 'sin'">
      <label>
        Sin Amplitude:
        <input type="range" v-model="sinAmplitude" min="0" max="10" value="1">
      </label>
      <label>
        Sin Frequency:
        <input type="range" v-model="sinFrequency" min="0" max="1" value="0.1">
      </label>
    </template>
    <template v-if="surfaceType === 'gaussian'">
      <label>
        Gaussian Center:
        <input type="range" v-model="gaussianCenter" min="0" max="800" value="400">
      </label>
      <label>
        Gaussian Radius:
        <input type="range" v-model="gaussianRadius" min="0" max="800" value="200">
      </label>
      <label>
        Gaussian Height:
        <input type="range" v-model="gaussianHeight" min="0" max="100" value="40">
      </label>
      <label>
        Warp Alpha:
        <input type="range" v-model="warpAlpha" min="0" max="100" value="10">
      </label>
    </template>
    <label>
      Surface:
      <select v-model="surfaceType">
        <option value="sin">Sin Bumps</option>
        <option value="gaussian">Gaussian Hill</option>
      </select>
    </label>
    <button @click="draw">Redraw</button>
  </div>
  <canvas ref="canvas" width="800" height="800"></canvas>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'

const spacing = ref(30)
const surfaceType = ref('sin')
const sinAmplitude = ref(1)
const sinFrequency = ref(0.1)
const gaussianCenter = ref(400)
const gaussianRadius = ref(200)
const gaussianHeight = ref(40)
const warpAlpha = ref(10)

function f_sin(x, y) {
  return sinAmplitude.value * Math.sin(x * sinFrequency.value) * Math.sin(y * sinFrequency.value)
}

function f_gaussian(x, y) {
  const dx = x - gaussianCenter.value
  const dy = y - gaussianCenter.value
  const r2 = (dx * dx + dy * dy) / (gaussianRadius.value * gaussianRadius.value)
  return gaussianHeight.value * Math.exp(-r2)
}

function grad_f(f, x, y, eps = 1) {
  const fx = (f(x + eps, y) - f(x - eps, y)) / (2 * eps)
  const fy = (f(x, y + eps) - f(x, y - eps)) / (2 * eps)
  return { x: fx, y: fy }
}

function warpPoint(x, y, f) {
  const g = grad_f(f, x, y)
  const alpha = warpAlpha.value / 1000
  return {
    x: x + alpha * g.x,
    y: y + alpha * g.y
  }
}

function draw() {
  const canvas = canvasRef.value
  if (!canvas) return
  
  const ctx = canvas.getContext('2d')
  const width = canvas.width
  const height = canvas.height
  
  ctx.clearRect(0, 0, width, height)
  
  const f = surfaceType.value === 'sin' ? f_sin : f_gaussian
  
  // Draw grid lines
  ctx.strokeStyle = '#ccc'
  ctx.lineWidth = 1
  
  // Horizontal lines
  for (let y = 0; y < height; y += spacing.value) {
    ctx.beginPath()
    for (let x = 0; x < width; x += 10) {
      const warped = warpPoint(x, y, f)
      if (x === 0) {
        ctx.moveTo(warped.x, warped.y)
      } else {
        ctx.lineTo(warped.x, warped.y)
      }
    }
    ctx.stroke()
  }
  
  // Vertical lines
  for (let x = 0; x < width; x += spacing.value) {
    ctx.beginPath()
    for (let y = 0; y < height; y += 10) {
      const warped = warpPoint(x, y, f)
      if (y === 0) {
        ctx.moveTo(warped.x, warped.y)
      } else {
        ctx.lineTo(warped.x, warped.y)
      }
    }
    ctx.stroke()
  }
}

const canvasRef = ref(null)

onMounted(() => {
  draw()
})
</script>

<style scoped>
body {
  margin: 0;
  padding: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  background-color: #f5f5f5;
  font-family: Arial, sans-serif;
}

h1 {
  text-align: center;
  margin-bottom: 20px;
  color: #333;
}

.controls {
  margin-bottom: 20px;
  display: flex;
  flex-direction: column;
  gap: 10px;
  background: white;
  padding: 20px;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}

label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 10px;
}

canvas {
  background: white;
  border-radius: 8px;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
}
</style>
